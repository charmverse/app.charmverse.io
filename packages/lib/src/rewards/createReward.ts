import type { Page, PagePermission, Prisma } from '@charmverse/core/prisma';
import { prisma } from '@charmverse/core/prisma-client';
import { extractPreviewImage } from '@packages/charmeditor/utils/extractPreviewImage';
import type { BoardFields } from '@packages/databases/board';
import type { RewardFields } from '@packages/lib/rewards/blocks/interfaces';
import { trackOpUserAction } from '@packages/metrics/mixpanel/trackOpUserAction';
import { NotFoundError } from '@packages/nextjs/errors';
import { generatePagePathFromPathAndTitle } from '@packages/pages/utils';
import { InvalidInputError } from '@packages/utils/errors';
import { v4 } from 'uuid';

import { getRewardOrThrow } from './getReward';
import { getRewardErrors } from './getRewardErrors';
import { getRewardType } from './getRewardType';
import type { UpdateableRewardFields } from './updateRewardSettings';

export type RewardPageProps = Partial<
  Pick<
    Page,
    'title' | 'content' | 'contentText' | 'sourceTemplateId' | 'headerImage' | 'icon' | 'type' | 'autoGenerated'
  >
>;

type PagePermissionsInput = Pick<PagePermission, 'permissionLevel'> &
  Partial<Pick<PagePermission, 'userId' | 'spaceId' | 'public'>>;

export type RewardCreationData = UpdateableRewardFields & {
  linkedPageId?: string;
  spaceId: string;
  userId: string;
  pageProps?: RewardPageProps;
  proposalId?: string | null;
  githubIssueUrl?: string;
  isDraft?: boolean;
  isPublic?: boolean;
};
/**
 * You can create a reward suggestion using only title, spaceId and createdBy. You will see many unit tests using this limited dataset, which will then default the reward to suggestion status. Your logic should account for this.
 */
export async function createReward({
  spaceId,
  userId,
  chainId = 1,
  linkedPageId,
  approveSubmitters = false,
  maxSubmissions,
  rewardAmount,
  rewardToken,
  rewardType,
  customReward = null,
  allowedSubmitterRoles,
  assignedSubmitters,
  dueDate,
  fields,
  reviewers,
  pageProps,
  selectedCredentialTemplates,
  allowMultipleApplications,
  proposalId,
  githubIssueUrl,
  isDraft,
  isPublic
}: RewardCreationData) {
  const errors = getRewardErrors({
    page: pageProps || null,
    linkedPageId,
    reward: { assignedSubmitters, rewardAmount, rewardToken, chainId, customReward, reviewers },
    rewardType: rewardType || getRewardType({ rewardAmount, rewardToken, chainId, customReward })
  });
  if (!isDraft && errors.length > 0) {
    throw new InvalidInputError(errors.join(', '));
  }

  const space = await prisma.space.findUniqueOrThrow({
    where: {
      id: spaceId
    },
    select: {
      id: true,
      publicBountyBoard: true,
      domain: true,
      defaultPagePermissionGroup: true
    }
  });

  const rewardBoardBlock = await prisma.rewardBlock.findUnique({
    where: {
      id_spaceId: {
        id: '__defaultBoard',
        spaceId
      }
    }
  });

  // dont create properties that were deleted
  if (rewardBoardBlock && (fields as unknown as RewardFields | undefined)?.properties) {
    (rewardBoardBlock.fields as unknown as BoardFields).cardProperties.forEach((property) => {
      if (property.deletedAt) {
        delete (fields as unknown as RewardFields).properties![property.id];
      }
    });
  }

  const rewardId = v4();

  const isAssignedReward = Array.isArray(assignedSubmitters) && assignedSubmitters.length > 0;

  const rewardCreateInput: Prisma.BountyCreateInput = {
    id: rewardId,
    space: {
      connect: {
        id: spaceId
      }
    },
    author: {
      connect: {
        id: userId
      }
    },
    status: isDraft ? 'draft' : 'open',
    githubIssueUrl,
    dueDate,
    fields: fields as any,
    chainId,
    approveSubmitters: isAssignedReward ? false : approveSubmitters,
    maxSubmissions: isAssignedReward ? 1 : maxSubmissions,
    rewardAmount,
    rewardToken,
    rewardType,
    customReward,
    selectedCredentialTemplates,
    allowMultipleApplications: isAssignedReward ? false : allowMultipleApplications,
    proposal: proposalId
      ? {
          connect: {
            id: proposalId
          }
        }
      : undefined
  };

  const rewardPermissions: Prisma.BountyPermissionCreateManyBountyInput[] = [];

  // assign submitter roles only if reward is not assigned
  if (isAssignedReward) {
    assignedSubmitters?.forEach((submitterUserId) =>
      rewardPermissions.push({
        permissionLevel: 'submitter',
        userId: submitterUserId
      })
    );
  } else {
    allowedSubmitterRoles?.forEach((roleId) =>
      rewardPermissions.push({
        permissionLevel: 'submitter',
        roleId
      })
    );
  }

  reviewers?.forEach((reviewer) => {
    rewardPermissions.push({
      userId: reviewer.userId,
      roleId: reviewer.roleId,
      permissionLevel: 'reviewer'
    });
  });

  let createdPageId: string | undefined;

  const pagePermissionsInput: PagePermissionsInput[] = [
    {
      permissionLevel: 'full_access',
      userId
    }
  ];

  if (!isDraft) {
    // Even if full access is granted, we don't want to grant full access to a reward, just make it visible
    if (space.defaultPagePermissionGroup) {
      pagePermissionsInput.push({
        permissionLevel: 'view',
        spaceId
      });
    }
  }

  if (isPublic) {
    pagePermissionsInput.push({
      permissionLevel: 'view',
      public: true
    });
  }

  if (!linkedPageId) {
    const galleryImage = pageProps?.content ? extractPreviewImage(pageProps.content as any) : null;
    const results = await prisma.bounty.create({
      data: {
        ...rewardCreateInput,
        permissions: {
          createMany: {
            data: rewardPermissions
          }
        },
        page: {
          create: {
            permissions: {
              createMany: {
                data: pagePermissionsInput
              }
            },
            id: rewardId,
            path: generatePagePathFromPathAndTitle({ title: pageProps?.title || '' }),
            space: {
              connect: {
                id: spaceId
              }
            },
            updatedBy: userId,
            author: {
              connect: {
                id: userId
              }
            },
            type: pageProps?.type ?? 'bounty',
            content: pageProps?.content ?? undefined,
            contentText: pageProps?.contentText ?? '',
            galleryImage,
            headerImage: pageProps?.headerImage,
            sourceTemplateId: pageProps?.sourceTemplateId,
            title: pageProps?.title ?? '',
            icon: pageProps?.icon,
            autoGenerated: pageProps?.autoGenerated ?? false
          }
        }
      },
      include: {
        page: true
      }
    });
    createdPageId = results.page?.id;
  } else {
    await prisma.$transaction(async (tx) => {
      await tx.bounty.create({
        data: {
          ...rewardCreateInput
        }
      });
      await tx.page.update({
        where: {
          id: linkedPageId
        },
        data: {
          bountyId: rewardId
        }
      });

      if (isPublic) {
        const existingPermission = await tx.pagePermission.findFirst({
          where: {
            public: {
              not: null
            },
            pageId: linkedPageId
          }
        });

        if (existingPermission) {
          await tx.pagePermission.update({
            where: {
              id: existingPermission.id
            },
            data: {
              public: true,
              permissionLevel: 'view'
            }
          });
        } else {
          await tx.pagePermission.create({
            data: {
              public: true,
              permissionLevel: 'view',
              pageId: linkedPageId
            }
          });
        }
      }
    });
  }

  if (space?.domain === 'op-grants') {
    trackOpUserAction('reward_opened', {
      userId,
      rewardId
    });
  }

  const reward = await getRewardOrThrow({ rewardId });
  return { reward, createdPageId };
}
