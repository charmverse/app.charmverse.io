import type { PageWithPermissions } from '@charmverse/core/pages';
import type { Proposal, ProposalWorkflow, Space, User } from '@charmverse/core/prisma-client';
import { prisma } from '@charmverse/core/prisma-client';
import { getCurrentEvaluation, type WorkflowEvaluationJson } from '@charmverse/core/proposals';
import { baseUrl } from '@packages/config/constants';
import { expect, test } from '__e2e__/utils/test';
import { v4 as uuid } from 'uuid';

import { createProposal } from '@packages/lib/proposals/createProposal';
import { emptyDocument } from 'lib/prosemirror/constants';

import { generateUser, generateUserAndSpace, loginBrowserUser } from '../utils/mocks';

test.describe.serial('Proposal Evaluations', () => {
  let space: Space;
  let member: User;
  let proposal: Proposal;
  let page: PageWithPermissions;

  const settingsToTest = {
    proposalTitle: 'Proposal test title',
    evaluationFeedbackTitle: 'Feedback Eval',
    evaluationPassFailTitle: 'Pass/Fail Eval',
    evaluationPassFail2Title: 'Pass/Fail 2 Eval'
  };

  const proposalEvaluationPermissions: WorkflowEvaluationJson[] = [
    {
      id: uuid(),
      title: settingsToTest.evaluationFeedbackTitle,
      permissions: [
        { systemRole: 'all_reviewers', operation: 'comment' },
        { operation: 'view', systemRole: 'space_member' }
      ],
      type: 'feedback'
    },
    {
      id: uuid(),
      title: settingsToTest.evaluationPassFailTitle,
      permissions: [
        { systemRole: 'all_reviewers', operation: 'comment' },
        { operation: 'view', systemRole: 'space_member' }
      ],
      type: 'pass_fail',
      finalStep: true
    },
    {
      id: uuid(),
      title: settingsToTest.evaluationPassFail2Title,
      permissions: [
        { systemRole: 'all_reviewers', operation: 'comment' },
        { operation: 'view', systemRole: 'space_member' }
      ],
      type: 'pass_fail'
    }
  ];

  let workflow: ProposalWorkflow;

  test.beforeAll(async () => {
    ({ space } = await generateUserAndSpace({
      isAdmin: true,
      spaceDomain: `cvt-${uuid()}`,
      memberSpacePermissions: ['createProposals', 'reviewProposals']
    }));
    member = await generateUser({ space: { id: space.id, isAdmin: false } });
    workflow = await prisma.proposalWorkflow.create({
      data: {
        index: 0,
        title: 'Default flow',
        space: { connect: { id: space.id } },
        evaluations: proposalEvaluationPermissions
      }
    });

    const result = await createProposal({
      authors: [member.id],
      evaluations: proposalEvaluationPermissions.map((e, index) => ({
        ...e,
        reviewers: [
          {
            userId: member.id
          }
        ],
        rubricCriteria: [],
        index
      })),
      pageProps: {
        autoGenerated: false,
        title: settingsToTest.proposalTitle,
        type: 'proposal',
        content: emptyDocument,
        contentText: ''
      },
      spaceId: space.id,
      userId: member.id,
      workflowId: workflow.id
    });
    proposal = result.proposal;
    page = result.page;
  });

  test('Create a proposal that uses each type of evaluation', async ({ proposalListPage, proposalPage }) => {
    // Initial setup
    await loginBrowserUser({
      browserPage: proposalListPage.page,
      userId: member.id
    });

    await proposalListPage.page.goto(`${baseUrl}/${space.domain}/${page.path}`);
    await proposalPage.passFeedbackEvaluation.click();

    await proposalPage.page.locator('data-test=evaluation-pass-button').nth(0).click();
    await proposalPage.page.waitForResponse('**/submit-result');

    const proposalEvaluations = await prisma.proposalEvaluation.findMany({
      where: {
        proposalId: proposal.id
      }
    });

    await expect(proposalPage.page.locator(`data-test=evaluation-passed-icon-3`)).toBeVisible();
    await expect(proposalPage.page.locator(`data-test=evaluation-passed-icon-4`)).not.toBeVisible();

    const currentEvaluation = getCurrentEvaluation(proposalEvaluations)!;
    expect(currentEvaluation.title).toBe(settingsToTest.evaluationPassFailTitle);
    expect(currentEvaluation.result).toBe('pass');
  });
});
