import type { Proposal, ProposalEvaluation, Space, User } from '@charmverse/core/prisma';
import { prisma } from '@charmverse/core/prisma-client';
import type { ProposalWorkflowTyped } from '@charmverse/core/proposals';
import { testUtilsUser } from '@charmverse/core/test';
import { baseUrl, loginUser } from '@packages/testing/mockApiCall';
import request from 'supertest';
import { v4 as uuid, v4 } from 'uuid';

import { createProposal } from '@packages/lib/proposals/createProposal';
import { emptyDocument } from 'lib/prosemirror/constants';

let space: Space;
let proposalCreator: User;
let spaceMember: User;
let admin: User;
let workflow: ProposalWorkflowTyped;
let proposal: Proposal & {
  evaluations: ProposalEvaluation[];
};
let evaluationId: string;

beforeAll(async () => {
  const generated = await testUtilsUser.generateUserAndSpace({ isAdmin: false });
  space = generated.space;
  proposalCreator = generated.user;
  spaceMember = await testUtilsUser.generateSpaceUser({
    spaceId: space.id
  });
  admin = await testUtilsUser.generateSpaceUser({
    spaceId: space.id,
    isAdmin: true
  });

  workflow = (await prisma.proposalWorkflow.create({
    data: {
      index: 0,
      title: 'Default flow',
      spaceId: space.id,
      evaluations: [
        {
          id: uuid(),
          title: 'Pass/fail',
          permissions: [
            { systemRole: 'all_reviewers', operation: 'comment' },
            { operation: 'view', systemRole: 'space_member' }
          ],
          reviewers: [{ group: 'user', id: admin.id }],
          appealable: true,
          appealRequiredReviews: 1,
          appealReviewers: [
            {
              userId: admin.id
            }
          ],
          type: 'pass_fail'
        }
      ]
    }
  })) as ProposalWorkflowTyped;

  const result = await createProposal({
    evaluations: [
      {
        type: 'pass_fail',
        reviewers: [{ userId: admin.id }],
        title: 'Pass/fail',
        index: 0,
        rubricCriteria: [],
        id: v4()
      }
    ],
    authors: [proposalCreator.id],
    pageProps: {
      autoGenerated: false,
      content: { ...emptyDocument },
      contentText: 'Empty proposal',
      title: 'Proposal title'
    },
    spaceId: space.id,
    userId: proposalCreator.id,
    workflowId: workflow.id
  });

  proposal = await prisma.proposal.findUniqueOrThrow({
    where: {
      id: result.proposal.id
    },
    include: {
      evaluations: true
    }
  });

  evaluationId = proposal.evaluations[0].id;
});

describe('POST /api/proposals/evaluations/[id]/appeal - Create a proposal and appeal failed evaluation review', () => {
  it('should fail to appeal if the user is not a proposal author nor an admin and respond with 401', async () => {
    const userCookie = await loginUser(spaceMember.id);
    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(401);
    expect(response.body.message).toBe('Only authors and admins can appeal evaluations');
  });

  it('should fail to appeal if the evaluation is still ongoing and result is not failed and respond with 401', async () => {
    const userCookie = await loginUser(proposalCreator.id);
    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(401);
    expect(response.body.message).toBe('Only failed evaluations can be appealed');
  });

  it('should fail to appeal if the evaluation is not appealable and respond with 401', async () => {
    await prisma.proposalEvaluation.update({
      where: { id: evaluationId },
      data: { appealable: false, result: 'fail' }
    });
    const userCookie = await loginUser(proposalCreator.id);
    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(401);
    expect(response.body.message).toBe('This evaluation is not appealable');

    await prisma.proposalEvaluation.update({
      where: { id: evaluationId },
      data: { appealable: true }
    });
  });

  it('should fail to appeal if the evaluation has already been appealed and respond with 401', async () => {
    await prisma.proposalEvaluation.update({
      where: { id: evaluationId },
      data: { appealedAt: new Date() }
    });
    const userCookie = await loginUser(proposalCreator.id);
    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(401);
    expect(response.body.message).toBe('This evaluation has already been appealed');

    await prisma.proposalEvaluation.update({
      where: { id: evaluationId },
      data: { appealedAt: null }
    });
  });

  it('should successfully appeal the evaluation as an admin and respond with 200', async () => {
    const userCookie = await loginUser(admin.id);
    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(200);

    const updatedEvaluation = await prisma.proposalEvaluation.findUniqueOrThrow({
      where: { id: evaluationId },
      select: {
        appealedAt: true,
        result: true,
        appealedBy: true,
        completedAt: true
      }
    });

    expect(updatedEvaluation).toStrictEqual({
      appealedAt: expect.any(Date),
      result: null,
      appealedBy: admin.id,
      completedAt: null
    });
  });

  it('should successfully appeal the evaluation as an author and respond with 200', async () => {
    const userCookie = await loginUser(proposalCreator.id);
    await prisma.proposalEvaluationAppealReview.deleteMany({
      where: {
        evaluationId
      }
    });
    await prisma.proposalEvaluation.update({
      where: { id: evaluationId },
      data: { appealedAt: null, result: 'fail' }
    });

    const response = await request(baseUrl)
      .put(`/api/proposals/evaluations/${evaluationId}/appeal`)
      .set('Cookie', userCookie);
    expect(response.statusCode).toBe(200);

    const updatedEvaluation = await prisma.proposalEvaluation.findUniqueOrThrow({
      where: { id: evaluationId },
      select: {
        appealedAt: true,
        result: true,
        appealedBy: true,
        completedAt: true
      }
    });

    expect(updatedEvaluation).toStrictEqual({
      appealedAt: expect.any(Date),
      result: null,
      appealedBy: proposalCreator.id,
      completedAt: null
    });
  });
});
